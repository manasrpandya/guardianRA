#include <tk/tkernel.h>
#include <tm/tmonitor.h>
#include <string.h>

#include "config.h"
#include "log.h"
#include "heuristic.h"
#include "features.h"
#include "diagnostics.h"
#include "events.h"
#include "scaler.h"      /* generated by offline export */
#include "ae_model.h"    /* generated by offline export */

/*
 * Realistic µSentinel runtime monitor
 * - Periodic acquisition of FEATURE_DIM features (placeholder implementation shown)
 * - Heuristic baseline + AE inference
 * - Moving statistics (EMA of error, event counters)
 * - Human-readable and optional CSV logs over T-Monitor
 */

#ifndef MONITOR_PERIOD_MS
#define MONITOR_PERIOD_MS   (200)
#endif

#define RING_N   (128)

typedef struct {
    float vals[RING_N];
    unsigned int head;
    unsigned int count;
} ringf_t;

static ringf_t g_err_hist;
static unsigned long g_sample_idx = 0;
static unsigned long g_anom_count = 0;
static float g_err_ema = 0.0f;     /* exponential moving average */
static const float ERR_EMA_ALPHA = 0.1f;
static heuristic_cfg_t g_heur_cfg;
static int g_csv_header_printed = 0;

static inline void ring_push(ringf_t *rb, float v)
{
    rb->vals[rb->head] = v;
    rb->head = (rb->head + 1u) % RING_N;
    if (rb->count < RING_N) rb->count++;
}

static float ring_avg(const ringf_t *rb)
{
    if (!rb->count) return 0.0f;
    float s = 0.0f;
    for (unsigned int i = 0; i < rb->count; ++i) s += rb->vals[i];
    return s / (float)rb->count;
}

static unsigned long systime_ms(void)
{
    /* Portable µT‑Kernel time: tk_get_tim() */
    SYSTIM t;
    tk_get_tim(&t);
    /* If t.lo is already milliseconds in your config, return (unsigned long)t.lo */
    return (unsigned long)(t.lo / 1000u);
}

static void print_csv_header_if_needed(void)
{
#if ENABLE_CSV_LOG
    if (!g_csv_header_printed) {
        tm_printf((UB*)"%s\n", (UB*)CSV_HEADER);
        g_csv_header_printed = 1;
    }
#endif
}

void monitor_init(void)
{
    heuristic_init(&g_heur_cfg);
    g_err_hist.head = 0; g_err_hist.count = 0;
    g_sample_idx = 0; g_anom_count = 0; g_err_ema = 0.0f;

    diag_init();
    events_init();

    LOG_INFO("µSentinel monitor_init: FEATURE_DIM=%d LATENT_DIM=%d period_ms=%d", FEATURE_DIM, LATENT_DIM, MONITOR_PERIOD_MS);
    print_csv_header_if_needed();
}

void monitor_start(void)
{
    static float feat[FEATURE_DIM];
    while (1)
    {
        features_acquire(feat, FEATURE_DIM);

        /* Heuristic */
        const int heur_anom =
            heuristic_eval(feat, FEATURE_DIM, g_scaler_mean, g_scaler_std, &g_heur_cfg);

        /* Autoencoder */
        const float err = ae_infer_recon_error(feat);
        const int ae_anom = (err > g_anomaly_threshold);

        /* Moving statistics */
        g_err_ema = (1.0f - ERR_EMA_ALPHA) * g_err_ema + ERR_EMA_ALPHA * err;
        ring_push(&g_err_hist, err);
        if (ae_anom || heur_anom) g_anom_count++;

        const unsigned long t_ms = systime_ms();
        const diag_snapshot_t ds = diag_read();

        /* Events aggregation */
        event_kind_t kind = EV_NONE;
        if (ae_anom && heur_anom) kind = EV_BOTH;
        else if (ae_anom) kind = EV_AE_ONLY;
        else if (heur_anom) kind = EV_HEUR_ONLY;
        if (kind != EV_NONE) {
            events_record(kind, (uint32_t)t_ms, err, g_err_ema, ae_anom, heur_anom);
        }

        /* Human-readable log */
        tm_printf((UB*)"[µSentinel] t=%lu ms | err=%.6f ema=%.6f thr=%.6f | AE=%s HEUR=%s | ctx=%lu isr=%lu mem=%lu/%lu | anom_total=%lu\n",
                  t_ms, err, g_err_ema, g_anomaly_threshold,
                  ae_anom ? (UB*)"ANOM" : (UB*)"ok",
                  heur_anom ? (UB*)"ANOM" : (UB*)"ok",
                  (unsigned long)ds.ctx_switches, (unsigned long)ds.isr_count,
                  (unsigned long)ds.mem_free_bytes, (unsigned long)ds.mem_total_bytes,
                  g_anom_count);

#if ENABLE_CSV_LOG
        /* Compact CSV line: time_ms,err,thr,ae_label,heur_label,first few features */
        tm_printf((UB*)"%lu,%.6f,%.6f,%.6f,%d,%d,%lu,%lu,%lu,%lu,%.5f,%.5f,%.5f,%.5f,%.5f,%.5f\n",
                  t_ms, err, g_err_ema, g_anomaly_threshold, ae_anom, heur_anom,
                  (unsigned long)ds.ctx_switches, (unsigned long)ds.isr_count,
                  (unsigned long)ds.mem_free_bytes, (unsigned long)ds.mem_total_bytes,
                  feat[0], feat[1], feat[2], feat[3], feat[4], feat[5]);
#endif

        g_sample_idx++;

        /* Periodic summary */
        if ((g_sample_idx % SUMMARY_EVERY_SAMPLES) == 0u) {
            uint32_t c_h = 0, c_a = 0, c_b = 0;
            events_get_counts(&c_h, &c_a, &c_b);
            const float avg_err = ring_avg(&g_err_hist);
            LOG_INFO("summary: samples=%lu avg_err=%.6f ema=%.6f thr=%.6f counts{heur=%lu, ae=%lu, both=%lu}",
                     g_sample_idx, avg_err, g_err_ema, g_anomaly_threshold,
                     (unsigned long)c_h, (unsigned long)c_a, (unsigned long)c_b);
        }
        tk_dly_tsk(MONITOR_PERIOD_MS);
    }
}
