#include <tk/tkernel.h>
#include <tm/tmonitor.h>
#include <string.h>
#include <stdint.h>

#include "config.h"
#include "log.h"
#include "heuristic.h"
#include "features.h"
#include "diagnostics.h"
#include "events.h"
#include "scaler.h"      /* generated by offline export */
#include "ae_model.h"    /* generated by offline export */

/*
 * Realistic µSentinel runtime monitor
 * - Periodic acquisition of FEATURE_DIM features (placeholder implementation shown)
 * - Heuristic baseline + AE inference
 * - Moving statistics (EMA of error, event counters)
 * - Human-readable and optional CSV logs over T-Monitor
 */

#ifndef MONITOR_PERIOD_MS
#define MONITOR_PERIOD_MS   (200)
#endif

#define RING_N   (128)

typedef struct {
    float vals[RING_N];
    unsigned int head;
    unsigned int count;
} ringf_t;

static ringf_t g_err_hist;
static unsigned long g_sample_idx = 0;
static unsigned long g_anom_count = 0;
static float g_err_ema = 0.0f;     /* exponential moving average */
static const float ERR_EMA_ALPHA = 0.1f;
static heuristic_cfg_t g_heur_cfg;
static int g_csv_header_printed = 0;

static inline void ring_push(ringf_t *rb, float v)
{
    rb->vals[rb->head] = v;
    rb->head = (rb->head + 1u) % RING_N;
    if (rb->count < RING_N) rb->count++;
}

static float ring_avg(const ringf_t *rb)
{
    if (!rb->count) return 0.0f;
    float s = 0.0f;
    for (unsigned int i = 0; i < rb->count; ++i) s += rb->vals[i];
    return s / (float)rb->count;
}

static unsigned long systime_ms(void)
{
    /* Portable µT‑Kernel time: tk_get_tim() */
    SYSTIM t;
    tk_get_tim(&t);
    /* If t.lo is already milliseconds in your config, return (unsigned long)t.lo */
    return (unsigned long)(t.lo / 1000u);
}

static void print_csv_header_if_needed(void)
{
#if ENABLE_CSV_LOG
    if (!g_csv_header_printed) {
        tm_printf((UB*)"%s\n", (UB*)CSV_HEADER);
        g_csv_header_printed = 1;
    }
#endif
}

void monitor_init(void)
{
    heuristic_init(&g_heur_cfg);
    g_err_hist.head = 0; g_err_hist.count = 0;
    g_sample_idx = 0; g_anom_count = 0; g_err_ema = 0.0f;

    diag_init();
    events_init();

    LOG_INFO("µSentinel monitor_init: FEATURE_DIM=%d LATENT_DIM=%d period_ms=%d", FEATURE_DIM, LATENT_DIM, MONITOR_PERIOD_MS);
    print_csv_header_if_needed();
}

void monitor_start(void)
{
    static float feat[FEATURE_DIM];
    while (1)
    {
        features_acquire(feat, FEATURE_DIM);

        /* Heuristic */
        const int heur_anom =
            heuristic_eval(feat, FEATURE_DIM, g_scaler_mean, g_scaler_std, &g_heur_cfg);

        /* Autoencoder */
        const float err = ae_infer_recon_error(feat);
        const int ae_anom = (err > g_anomaly_threshold);

        /* Moving statistics */
        g_err_ema = (1.0f - ERR_EMA_ALPHA) * g_err_ema + ERR_EMA_ALPHA * err;
        ring_push(&g_err_hist, err);
        if (ae_anom || heur_anom) g_anom_count++;

        const unsigned long t_ms = systime_ms();
        const diag_snapshot_t ds = diag_read();

        /* Events aggregation */
        event_kind_t kind = EV_NONE;
        if (ae_anom && heur_anom) kind = EV_BOTH;
        else if (ae_anom) kind = EV_AE_ONLY;
        else if (heur_anom) kind = EV_HEUR_ONLY;
        if (kind != EV_NONE) {
            events_record(kind, (uint32_t)t_ms, err, g_err_ema, ae_anom, heur_anom);
        }

        /* Format fixed-point floats (Q.3) to avoid %f in tm_printf */
        int err_i, err_f, ema_i, ema_f, thr_i, thr_f;
        {
            int32_t fx = (int32_t)(err * 1000.0f); err_i = fx / 1000; err_f = fx % 1000; if (err_f < 0) err_f = -err_f;
            fx = (int32_t)(g_err_ema * 1000.0f);    ema_i = fx / 1000; ema_f = fx % 1000; if (ema_f < 0) ema_f = -ema_f;
            fx = (int32_t)(g_anomaly_threshold * 1000.0f); thr_i = fx / 1000; thr_f = fx % 1000; if (thr_f < 0) thr_f = -thr_f;
        }

        /* Human-readable log (no %f) */
        tm_printf((UB*)"[µSentinel] t=%lu ms | err=%d.%03d ema=%d.%03d thr=%d.%03d | AE=%s HEUR=%s | ctx=%lu isr=%lu mem=%lu/%lu | anom_total=%lu\n",
                  t_ms, err_i, err_f, ema_i, ema_f, thr_i, thr_f,
                  ae_anom ? (UB*)"ANOM" : (UB*)"ok",
                  heur_anom ? (UB*)"ANOM" : (UB*)"ok",
                  (unsigned long)ds.ctx_switches, (unsigned long)ds.isr_count,
                  (unsigned long)ds.mem_free_bytes, (unsigned long)ds.mem_total_bytes,
                  g_anom_count);

#if ENABLE_CSV_LOG
        /* Compact CSV line using fixed-point (Q.3) for floats */
        int f0_i, f0_f, f1_i, f1_f, f2_i, f2_f, f3_i, f3_f, f4_i, f4_f, f5_i, f5_f;
        {
            int32_t fx;
            fx = (int32_t)(feat[0] * 1000.0f); f0_i = fx / 1000; f0_f = fx % 1000; if (f0_f < 0) f0_f = -f0_f;
            fx = (int32_t)(feat[1] * 1000.0f); f1_i = fx / 1000; f1_f = fx % 1000; if (f1_f < 0) f1_f = -f1_f;
            fx = (int32_t)(feat[2] * 1000.0f); f2_i = fx / 1000; f2_f = fx % 1000; if (f2_f < 0) f2_f = -f2_f;
            fx = (int32_t)(feat[3] * 1000.0f); f3_i = fx / 1000; f3_f = fx % 1000; if (f3_f < 0) f3_f = -f3_f;
            fx = (int32_t)(feat[4] * 1000.0f); f4_i = fx / 1000; f4_f = fx % 1000; if (f4_f < 0) f4_f = -f4_f;
            fx = (int32_t)(feat[5] * 1000.0f); f5_i = fx / 1000; f5_f = fx % 1000; if (f5_f < 0) f5_f = -f5_f;
        }
        tm_printf((UB*)"%lu,%d.%03d,%d.%03d,%d.%03d,%d,%d,%lu,%lu,%lu,%lu,%d.%03d,%d.%03d,%d.%03d,%d.%03d,%d.%03d,%d.%03d\n",
                  t_ms, err_i, err_f, ema_i, ema_f, thr_i, thr_f, ae_anom, heur_anom,
                  (unsigned long)ds.ctx_switches, (unsigned long)ds.isr_count,
                  (unsigned long)ds.mem_free_bytes, (unsigned long)ds.mem_total_bytes,
                  f0_i, f0_f, f1_i, f1_f, f2_i, f2_f, f3_i, f3_f, f4_i, f4_f, f5_i, f5_f);
#endif

        g_sample_idx++;

        /* Periodic summary */
        if ((g_sample_idx % SUMMARY_EVERY_SAMPLES) == 0u) {
            uint32_t c_h = 0, c_a = 0, c_b = 0;
            events_get_counts(&c_h, &c_a, &c_b);
            const float avg_err = ring_avg(&g_err_hist);
            LOG_INFO("summary: samples=%lu avg_err=%.6f ema=%.6f thr=%.6f counts{heur=%lu, ae=%lu, both=%lu}",
                     g_sample_idx, avg_err, g_err_ema, g_anomaly_threshold,
                     (unsigned long)c_h, (unsigned long)c_a, (unsigned long)c_b);
        }
        tk_dly_tsk(MONITOR_PERIOD_MS);
    }
}
